(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{381:function(_,v,t){"use strict";t.r(v);var e=t(17),a=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"eip-3541-拒絕以-0xef-開頭的新合約程式碼"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eip-3541-拒絕以-0xef-開頭的新合約程式碼"}},[_._v("#")]),_._v(" EIP-3541: 拒絕以 "),v("code",[_._v("0xEF")]),_._v(" 開頭的新合約程式碼")]),_._v(" "),v("h2",{attrs:{id:"摘要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[_._v("#")]),_._v(" 摘要")]),_._v(" "),v("p",[_._v("在 EIP-3541 生效後，禁止部署以 0xEF 位元組開頭的新合約程式碼。\n若在本 EIP 生效以前，就存在的合約則不會受此 EIP 的限制，依然會保持原語意上的邏輯。")]),_._v(" "),v("h2",{attrs:{id:"動機"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#動機"}},[_._v("#")]),_._v(" 動機")]),_._v(" "),v("p",[_._v("為了確保能夠精準辨識出 EOF 合約與傳統的 EVM 合約，進而避免將過去已經部署或者未來可能部署的傳統 EVM 合約誤認為是 EOF 合約，因此需要一套機制來區分這兩者。\n而在資訊工程領域，非常常見的做法是在每個檔案的開頭加入一個特定的標記，這個標記就是所謂的「魔術位元」（Magic Byte）。我們可以透過這個標記來區分不同的檔案類型，進而達到我們的目的。比如以下幾個例子：")]),_._v(" "),v("ol",[v("li",[_._v("腳本語言使用 "),v("code",[_._v("#!")]),_._v(" 作為開頭")]),_._v(" "),v("li",[_._v("壓縮格式 "),v("code",[_._v("bz2")]),_._v(" 使用 "),v("code",[_._v("BZh")]),_._v(" 作為開頭")]),_._v(" "),v("li",[_._v("圖片格式 "),v("code",[_._v("PNG")]),_._v(" 使用 "),v("code",[_._v("0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A")]),_._v(" 作為開頭")]),_._v(" "),v("li",[_._v("文件格式 "),v("code",[_._v("PDF")]),_._v(" 使用 "),v("code",[_._v("%PDF-")]),_._v(" 作為開頭")]),_._v(" "),v("li",[_._v("音樂格式 "),v("code",[_._v("flac")]),_._v(" 使用 "),v("code",[_._v("fLaC")]),_._v(" 作為開頭")])]),_._v(" "),v("p",[_._v("因此，EOF 合約選擇了過去不曾被使用個位元組 "),v("code",[_._v("0xEF")]),_._v(" 作為開頭，來作為區分 EOF 合約與傳統 EVM 合約的標記。\n請注意，此處所指的「不曾被使用」是指沒有被定義成指令過，而非在鏈上沒有被部署過的位元組。")]),_._v(" "),v("p",[_._v("根據 EIP-3541 的規範，原作者宣稱使用 "),v("code",[_._v("0xEF")]),_._v(" 是因為這個縮寫剛好是 "),v("code",[_._v("E")]),_._v("xecutable "),v("code",[_._v("F")]),_._v("ormat 的前兩個字母，聽起來更加合理了呢 😄。")]),_._v(" "),v("p",[_._v("如果未來 EOF 決定被撤銷或者不再需要使用這個魔術位元，我們可以簡單地透過新的 EIP 在某次分岔後重新允許以 0xEF 位元組開頭的合約部署，如此一來就能夠打消此限制。")]),_._v(" "),v("h2",{attrs:{id:"技術規格"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#技術規格"}},[_._v("#")]),_._v(" 技術規格")]),_._v(" "),v("p",[_._v("當區塊高度大於等於硬分岔區塊（"),v("code",[_._v("HF_BLOCK")]),_._v("）後，若透過建立合約交易（create transaction）、或 CREATE/CREATE2 指令來建立新合約時，如果合約程式碼的第一個位元組是 0xEF，則會觸發異常中止。")]),_._v(" "),v("h2",{attrs:{id:"相關細節"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相關細節"}},[_._v("#")]),_._v(" 相關細節")]),_._v(" "),v("p",[_._v("「初始化程式碼」（initcode）是在建立合約交易、CREATE 或 CREATE2 指令執行時所使用的程式碼。初始化程式碼會透過 RETURN 指令回傳最終部署的程式碼，並將這些程式碼放入合約帳戶中。")]),_._v(" "),v("p",[_._v("目前 0xEF 是一個未定義的指令，目前的 EVM 在執行到此指令時，只會導致異常中止，因此當以 "),v("code",[_._v("0xEF")]),_._v(" 開頭的初始化程式碼或者已經被部署的合約程式碼在執行到此指令時，會馬上觸發異常中止。這確保了導入這個機制後，不會破壞原有的執行邏輯。\n此外，此異常中止的行為與初始化程式碼執行期間可能發生的任何其他異常中止完全相同。因此，在異常中止的情況下，所有提供給 CREATE* 或建立合約交易的 gas 都會被消耗殆盡。")]),_._v(" "),v("h2",{attrs:{id:"其他考量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他考量"}},[_._v("#")]),_._v(" 其他考量")]),_._v(" "),v("p",[_._v("在規格書中有提到，雖然目前以下幾個指令已經不再使用：0xFD（REVERT）、0xFE（INVALID）和 0xFF（SELFDESTRUCT）。但在過去依然是有效的指令，因此為了避免與過去的合約程式碼混淆，才特意選一個目前沒被使用過的位元組 "),v("code",[_._v("0xEF")]),_._v("。")]),_._v(" "),v("p",[_._v("此外，在本 EIP 被提出時，作者於 2021 年 5 月對整個區塊鏈上 18,084,433 個合約進行分析，發現沒有已經被部署的合約以 0xEF 位元組開頭，相對地，以 0xFD、0xFE 和 0xFF 開頭的合約分別有 1 個、4 個和 12 個。雖然後來在這個 EIP 被部署之前，有其他開發者刻意去部署了以 "),v("code",[_._v("0xEF")]),_._v(" 開頭的合約，但都是偏向紀念性質的合約，並沒有真正的用途。")]),_._v(" "),v("h2",{attrs:{id:"參考資料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#參考資料"}},[_._v("#")]),_._v(" 參考資料")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://eips.ethereum.org/EIPS/eip-3541",target:"_blank",rel:"noopener noreferrer"}},[_._v("EIP-3541 規格文件"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=a.exports}}]);