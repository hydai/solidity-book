(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{381:function(t,v,_){"use strict";_.r(v);var e=_(17),a=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"eip-3540-eofv1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eip-3540-eofv1"}},[t._v("#")]),t._v(" EIP-3540 EOFv1")]),t._v(" "),v("p",[t._v("EOF 與傳統 EVM 合約的最大差異在於 EOF 具備了版本控制的能力，能夠在標記處表示該位元組碼是使用哪個版本的格式，因此他也具備了可擴充性，我們能在版本與版本之間提供更明確的相容性、更清晰的功能增減等。\n要特別注意的是，在 EOF 中引入了一個新的概念，稱為「容器格式("),v("code",[t._v("container format")]),t._v(")」，將位元組碼以特定的方式包裝起來，在部署時進行一次性驗證，並減少在執行期間的驗證機制。")]),t._v(" "),v("h2",{attrs:{id:"相依性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相依性"}},[t._v("#")]),t._v(" 相依性")]),t._v(" "),v("p",[t._v("本 EIP 依賴於以下特定幾個 EIPs")]),t._v(" "),v("ul",[v("li",[t._v("3541")]),t._v(" "),v("li",[t._v("3860")])]),t._v(" "),v("h2",{attrs:{id:"摘要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[t._v("#")]),t._v(" 摘要")]),t._v(" "),v("p",[t._v("在 EOF 出現之前，以太坊虛擬機(EVM)中部署的 EVM 位元組碼並沒有特定的格式與結構，因此程式碼區段與資料區段並沒有很好地分離，因此無法對程式碼進行有效率的分析。且過往並沒有版本控制的機制，因此每次引入新功能或者想要逃帶舊有的指令都是透過硬分岔來進行，這不止增加了開發者的負擔，也增加了合約的複雜度，還增加了 EVM 實作的複雜性。")]),t._v(" "),v("p",[t._v("為了解決這件事，在 EOF 中，我們將要求全部的 EOF 合約以本 EIP 所規定的格式進行部署：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("magic, version, (section_kind, section_size_or_sizes)+, 0, <section contents>\n")])])]),v("ul",[v("li",[t._v("magic: 魔術位元組，用來標記這是一個 EOF 合約")]),t._v(" "),v("li",[t._v("version: EOF 的版本號，用來標記這個合約是使用哪個版本的 EOF 格式，目前為 v1")]),t._v(" "),v("li",[t._v("section_kind: 區段的種類，用來標記這個區段是什麼類型")]),t._v(" "),v("li",[t._v("section_size_or_sizes: 區段的大小，用來標記對應區段的長度")]),t._v(" "),v("li",[t._v("0: 特殊的位元組，用來表示後面為區段的實際內容")]),t._v(" "),v("li",[t._v("section contents: 區段的實際內容，如程式碼、資料等")])]),t._v(" "),v("p",[t._v("因為在這個 EIP 中，我們分離了程式碼與資料，因此在編譯與部署時，以更低的成本對程式碼進行驗證，再加上版本控制能更輕鬆地導入各種變更。")]),t._v(" "),v("h2",{attrs:{id:"動機"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#動機"}},[t._v("#")]),t._v(" 動機")]),t._v(" "),v("p",[t._v("目前在鏈上部署的 EVM 位元組碼並沒有預先定義的結構。程式碼通常只在客戶端執行時進行 "),v("code",[t._v("JUMPDEST")]),t._v(" 分析，每次執行前都要重新分析一次。這不僅造成效能負擔，也使得引入新功能或淘汰舊功能變得困難。")]),t._v(" "),v("p",[t._v("在合約建立過程中進行程式碼驗證，可以不需要在帳戶中額外增加版本欄位就能實現程式碼版本控制。版本控制對於引入或淘汰功能非常有用，尤其是在進行較大規模的更動時(如控制流程的重大變更或帳戶抽象化等功能)。")]),t._v(" "),v("p",[t._v("本 EIP 描述的格式引入了一個簡單且可擴充的容器，只需要對客戶端和語言做最小程度的更改，同時也引入了驗證機制。")]),t._v(" "),v("p",[t._v("它提供的第一個具體功能是程式碼和資料的分離。這種分離對於鏈上程式碼驗證器(如 Optimism 等第二層擴容工具使用的驗證器)特別有益，因為它們可以區分程式碼和資料(包括部署程式碼和建構子參數)。目前，這些工具要麼 a) 需要在合約部署前進行修改；b) 實作一個脆弱的方法；或 c) 實作一個昂貴且受限的跳轉分析。程式碼和資料的分離可以讓這些用例更容易使用並節省大量 gas。此外，各種(靜態)分析工具也能受益，雖然離線工具已經可以處理現有程式碼，所以影響相對較小。")]),t._v(" "),v("p",[t._v("以下是一些可能受益於這種格式的提議變更(列表未完整)：")]),t._v(" "),v("ul",[v("li",[t._v("包含 "),v("code",[t._v("JUMPDEST")]),t._v(" 表格(避免執行時分析)和/或完全移除 "),v("code",[t._v("JUMPDEST")]),t._v("。")]),t._v(" "),v("li",[t._v("引入靜態跳轉(使用相對位址)和跳轉表，同時禁用動態跳轉。")]),t._v(" "),v("li",[t._v("多位元組操作碼，無需任何變通方案。")]),t._v(" "),v("li",[t._v("將函式表示為獨立的程式碼區段，而不是子程序。")]),t._v(" "),v("li",[t._v("為不同用途引入特殊區段，特別是帳戶抽象化。")])]),t._v(" "),v("h2",{attrs:{id:"規範"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#規範"}},[t._v("#")]),t._v(" 規範")]),t._v(" "),v("p",[t._v("為了確保狀態中的每個 EOF 格式的合約都是有效的，我們需要防止已經部署（且未經驗證）的合約被識別為此種格式。這是通過選擇一個在任何已部署合約中都不存在的位元組序列作為 "),v("em",[t._v("magic")]),t._v(" 來實現的。")]),t._v(" "),v("h3",{attrs:{id:"備註"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#備註"}},[t._v("#")]),t._v(" 備註")]),t._v(" "),v("p",[t._v("如果程式碼以 "),v("code",[t._v("MAGIC")]),t._v(" 開頭，則被視為 EOF 格式，否則被視為「舊式」程式碼。為了明確起見，"),v("code",[t._v("MAGIC")]),t._v(" 和版本號 "),v("em",[t._v("n")]),t._v(" 一起被表示為 "),v("em",[t._v("EOFn 前綴")]),t._v("，例如 "),v("em",[t._v("EOF1 前綴")]),t._v("。")]),t._v(" "),v("p",[t._v("EOF 格式的合約是使用在另一個 EIP 中引入的新指令來建立的。")]),t._v(" "),v("p",[t._v("操作碼 "),v("code",[t._v("0xEF")]),t._v(" 目前是一個未定義的指令，因此："),v("em",[t._v("它不會從堆疊中彈出任何項目，也不會推入任何項目，並且在執行時會導致異常中止")]),t._v("。這表示以此指令開頭的舊式 "),v("em",[t._v("初始化程式碼")]),t._v(" 或已部署的舊式 "),v("em",[t._v("程式碼")]),t._v(" 在執行時會繼續中止。")]),t._v(" "),v("p",[t._v("除非另有說明，所有整數都以大端序（big-endian）位元組順序編碼。")]),t._v(" "),v("h3",{attrs:{id:"程式碼驗證"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程式碼驗證"}},[t._v("#")]),t._v(" 程式碼驗證")]),t._v(" "),v("p",[t._v("我們針對新的合約建立引入了"),v("em",[t._v("程式碼驗證")]),t._v("機制。為了達成這個目標，我們定義了一個稱為 EVM 物件格式(EOF)的格式，其中包含了版本指示器，以及與特定版本綁定的有效性規則集。")]),t._v(" "),v("p",[t._v("舊式的程式碼不受 EOF 程式碼驗證的影響。")]),t._v(" "),v("p",[t._v("程式碼驗證會在合約建立時進行，並且在其他相關的 EIP 中有更詳細的說明。\nEOF 格式本身以及其正式的驗證方式將在以下章節中詳述。")]),t._v(" "),v("h3",{attrs:{id:"容器規格"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器規格"}},[t._v("#")]),t._v(" 容器規格")]),t._v(" "),v("p",[t._v("EOF 容器是一個二進位格式，具有提供 EOF 版本號碼和 EOF 區段清單的能力。")]),t._v(" "),v("p",[t._v("容器以 EOF 前綴開始：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("描述")]),t._v(" "),v("th",[t._v("長度")]),t._v(" "),v("th",[t._v("值")]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("magic")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0xEF00")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("version")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x01–0xFF")]),t._v(" "),v("td",[t._v("EOF 版本號")])])])]),t._v(" "),v("p",[t._v("EOF 前綴後面至少會接著一個區段標頭。每個區段標頭包含兩個欄位："),v("code",[t._v("section_kind")]),t._v(" 和 "),v("code",[t._v("section_size")]),t._v(" 或 "),v("code",[t._v("section_size_list")]),t._v("，具體取決於種類。當允許多個相同種類的區段時，"),v("code",[t._v("section_size_list")]),t._v(" 會以項目數量加上項目值的方式編碼一個大小值清單。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("描述")]),t._v(" "),v("th",[t._v("長度")]),t._v(" "),v("th",[t._v("值")]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("section_kind")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x01–0xFF")]),t._v(" "),v("td",[v("code",[t._v("uint8")])])]),t._v(" "),v("tr",[v("td",[t._v("section_size")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0000–0xFFFF")]),t._v(" "),v("td",[v("code",[t._v("uint16")])])]),t._v(" "),v("tr",[v("td",[t._v("section_size_list")]),t._v(" "),v("td",[t._v("動態")]),t._v(" "),v("td",[t._v("不適用")]),t._v(" "),v("td",[v("code",[t._v("uint16, uint16+")])])])])]),t._v(" "),v("p",[t._v("區段標頭清單以"),v("em",[t._v("區段標頭終止位元組")]),t._v(" "),v("code",[t._v("0x00")]),t._v(" 結尾。內容主體緊接在其後。")]),t._v(" "),v("h4",{attrs:{id:"容器驗證規則"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器驗證規則"}},[t._v("#")]),t._v(" 容器驗證規則")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("version")]),t._v(" 不得為 "),v("code",[t._v("0")]),t._v("。")]),t._v(" "),v("li",[v("code",[t._v("section_kind")]),t._v(" 不得為 "),v("code",[t._v("0")]),t._v("。值 "),v("code",[t._v("0")]),t._v(" 被保留作為"),v("em",[t._v("區段標頭終止位元組")]),t._v("使用。")]),t._v(" "),v("li",[t._v("必須至少包含一個區段（因此至少有一個區段標頭）。")]),t._v(" "),v("li",[t._v("不得存在區段以外的無效位元組。這包括最後一個區段後的尾隨位元組。")])]),t._v(" "),v("h3",{attrs:{id:"eof-版本-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eof-版本-1"}},[t._v("#")]),t._v(" EOF 版本 1")]),t._v(" "),v("p",[t._v("EOF 版本 1 由多個 EIP 組成，包括本規範。本規範中的一些數值只有簡要討論。要完整理解 EOF 的範圍，需要深入檢視每個相關的 EIP。")]),t._v(" "),v("h4",{attrs:{id:"容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[t._v("#")]),t._v(" 容器")]),t._v(" "),v("p",[t._v("EOF 版本 1 容器由「標頭」和「主體」組成。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("容器 := 標頭, 主體\n標頭 := \n    魔術位元組, 版本,\n    類型區段標記, 類型區段大小,\n    程式碼區段標記, 程式碼區段數量, 程式碼區段大小+,\n    [容器區段標記, 容器區段數量, 容器區段大小+,]\n    資料區段標記, 資料區段大小,\n    終止位元組\n主體 := 類型區段, 程式碼區段+, 容器區段*, 資料區段\n類型區段 := (輸入, 輸出, 最大堆疊高度)+\n")])])]),v("p",[v("em",[t._v("註："),v("code",[t._v(",")]),t._v(" 是串接運算子，"),v("code",[t._v("+")]),t._v(" 表示「前面項目一個或多個」，"),v("code",[t._v("*")]),t._v(" 表示「前面項目零個或多個」，而 "),v("code",[t._v("[項目]")]),t._v(" 表示可選項目。")])]),t._v(" "),v("h4",{attrs:{id:"標頭"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#標頭"}},[t._v("#")]),t._v(" 標頭")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名稱")]),t._v(" "),v("th",[t._v("長度")]),t._v(" "),v("th",[t._v("值")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("magic")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0xEF00")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("version")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x01")]),t._v(" "),v("td",[t._v("EOF 版本")])]),t._v(" "),v("tr",[v("td",[t._v("kind_type")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x01")]),t._v(" "),v("td",[t._v("類型區段的種類標記")])]),t._v(" "),v("tr",[v("td",[t._v("type_size")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0004-0x1000")]),t._v(" "),v("td",[t._v("16 位元無符號大端序整數，表示類型區段內容的長度，每個程式碼區段 4 位元組")])]),t._v(" "),v("tr",[v("td",[t._v("kind_code")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x02")]),t._v(" "),v("td",[t._v("程式碼大小區段的種類標記")])]),t._v(" "),v("tr",[v("td",[t._v("num_code_sections")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0001-0x0400")]),t._v(" "),v("td",[t._v("16 位元無符號大端序整數，表示程式碼區段的數量")])]),t._v(" "),v("tr",[v("td",[t._v("code_size")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0001-0xFFFF")]),t._v(" "),v("td",[t._v("16 位元無符號大端序整數，表示程式碼區段內容的長度")])]),t._v(" "),v("tr",[v("td",[t._v("kind_container")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x03")]),t._v(" "),v("td",[t._v("容器大小區段的種類標記")])]),t._v(" "),v("tr",[v("td",[t._v("num_container_sections")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0001-0x0100")]),t._v(" "),v("td",[t._v("16 位元無符號大端序整數，表示容器區段的數量")])]),t._v(" "),v("tr",[v("td",[t._v("container_size")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0001-0xFFFF")]),t._v(" "),v("td",[t._v("16 位元無符號大端序整數，表示容器區段內容的長度")])]),t._v(" "),v("tr",[v("td",[t._v("kind_data")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x04")]),t._v(" "),v("td",[t._v("資料大小區段的種類標記")])]),t._v(" "),v("tr",[v("td",[t._v("data_size")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0000-0xFFFF")]),t._v(" "),v("td",[t._v("16 位元無符號大端序整數，表示資料區段內容的長度 (*)")])]),t._v(" "),v("tr",[v("td",[t._v("terminator")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x00")]),t._v(" "),v("td",[t._v("標記標頭的結尾")])])])]),t._v(" "),v("p",[t._v("(*) 對於尚未部署的容器，這個值可以大於實際內容長度。")]),t._v(" "),v("h4",{attrs:{id:"主體"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主體"}},[t._v("#")]),t._v(" 主體")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名稱")]),t._v(" "),v("th",[t._v("長度")]),t._v(" "),v("th",[t._v("值")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("類型區段")]),t._v(" "),v("td",[t._v("可變")]),t._v(" "),v("td",[t._v("不適用")]),t._v(" "),v("td",[t._v("儲存程式碼區段的元資料")])]),t._v(" "),v("tr",[v("td",[t._v("輸入")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x00-0x7F")]),t._v(" "),v("td",[t._v("程式碼區段消耗的堆疊元素數量")])]),t._v(" "),v("tr",[v("td",[t._v("輸出")]),t._v(" "),v("td",[t._v("1 位元組")]),t._v(" "),v("td",[t._v("0x00-0x7F")]),t._v(" "),v("td",[t._v("程式碼區段回傳的堆疊元素數量")])]),t._v(" "),v("tr",[v("td",[t._v("最大堆疊高度")]),t._v(" "),v("td",[t._v("2 位元組")]),t._v(" "),v("td",[t._v("0x0000-0x03FF")]),t._v(" "),v("td",[t._v("程式碼區段在操作數堆疊上放置的元素最大數量")])]),t._v(" "),v("tr",[v("td",[t._v("程式碼區段")]),t._v(" "),v("td",[t._v("可變")]),t._v(" "),v("td",[t._v("不適用")]),t._v(" "),v("td",[t._v("任意位元組碼")])]),t._v(" "),v("tr",[v("td",[t._v("容器區段")]),t._v(" "),v("td",[t._v("可變")]),t._v(" "),v("td",[t._v("不適用")]),t._v(" "),v("td",[t._v("任意 EOF 格式的容器")])]),t._v(" "),v("tr",[v("td",[t._v("資料區段")]),t._v(" "),v("td",[t._v("可變")]),t._v(" "),v("td",[t._v("不適用")]),t._v(" "),v("td",[t._v("任意位元組序列")])])])]),t._v(" "),v("p",[t._v("請參閱 "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-4750.html"}},[t._v("EIP-4750")]),t._v(" 以取得關於類型區段內容的更多資訊。")],1),t._v(" "),v("p",[v("strong",[t._v("註")]),t._v(": 輸出的特殊值 "),v("code",[t._v("0x80")]),t._v(" 被指定用來表示在另一個 EIP 中定義的非回傳函式。")]),t._v(" "),v("h4",{attrs:{id:"eof-版本-1-驗證規則"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eof-版本-1-驗證規則"}},[t._v("#")]),t._v(" EOF 版本 1 驗證規則")]),t._v(" "),v("p",[t._v("容器格式必須符合以下有效性限制：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("types_size")]),t._v(" 必須可被 "),v("code",[t._v("4")]),t._v(" 整除")]),t._v(" "),v("li",[t._v("程式碼區段的數量必須等於 "),v("code",[t._v("types_size / 4")])]),t._v(" "),v("li",[t._v("對於尚未部署的容器，資料主體長度可以小於 "),v("code",[t._v("data_size")])]),t._v(" "),v("li",[t._v("容器的總大小不得超過 "),v("code",[t._v("MAX_INITCODE_SIZE")]),t._v("（定義於 "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-3860.html"}},[t._v("EIP-3860")]),t._v("）")],1)]),t._v(" "),v("h3",{attrs:{id:"執行語意的更改"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#執行語意的更改"}},[t._v("#")]),t._v(" 執行語意的更改")]),t._v(" "),v("p",[t._v("對於 EOF 合約：")]),t._v(" "),v("ul",[v("li",[t._v("執行從程式碼區段 0 的第一個位元組開始")]),t._v(" "),v("li",[v("code",[t._v("CODESIZE")]),t._v("、"),v("code",[t._v("CODECOPY")]),t._v("、"),v("code",[t._v("EXTCODESIZE")]),t._v("、"),v("code",[t._v("EXTCODECOPY")]),t._v("、"),v("code",[t._v("EXTCODEHASH")]),t._v("、"),v("code",[t._v("GAS")]),t._v(" 在 EOF 合約中被驗證機制拒絕，且沒有替代指令")]),t._v(" "),v("li",[v("code",[t._v("CALL")]),t._v("、"),v("code",[t._v("DELEGATECALL")]),t._v("、"),v("code",[t._v("STATICCALL")]),t._v(" 在 EOF 合約中被驗證機制拒絕，替代指令將在另一個 EIP 中引入")]),t._v(" "),v("li",[t._v("從 EOF 合約到非 EOF 合約(傳統合約、EOA、空帳戶)的 "),v("code",[t._v("EXTDELEGATECALL")]),t._v("（"),v("code",[t._v("DELEGATECALL")]),t._v(" 的替代品）是不被允許的，應該以與呼叫深度檢查失敗相同的方式失敗。我們允許從傳統合約到 EOF 合約的路徑，以便讓現有的代理合約能夠使用 EOF 升級。")])]),t._v(" "),v("p",[t._v("對於傳統合約：")]),t._v(" "),v("ul",[v("li",[t._v("如果 "),v("code",[t._v("EXTCODECOPY")]),t._v(" 的目標帳戶是 EOF 合約，則它將從 "),v("code",[t._v("EF00")]),t._v(" 複製最多 2 個位元組，就像那是程式碼一樣。")]),t._v(" "),v("li",[t._v("如果 "),v("code",[t._v("EXTCODEHASH")]),t._v(" 的目標帳戶是 EOF 合約，則它將回傳 "),v("code",[t._v("0x9dbf3648db8210552e9c4f75c6a1c3057c0ca432043bd648be15fe7be05646f5")]),t._v("（"),v("code",[t._v("EF00")]),t._v(" 的雜湊值，就像那是程式碼一樣）。")]),t._v(" "),v("li",[t._v("如果 "),v("code",[t._v("EXTCODESIZE")]),t._v(" 的目標帳戶是 EOF 合約，則它將回傳 2。")])]),t._v(" "),v("p",[v("strong",[t._v("註")]),t._v(" 與傳統目標一樣，上述 "),v("code",[t._v("EXTCODECOPY")]),t._v("、"),v("code",[t._v("EXTCODEHASH")]),t._v(" 和 "),v("code",[t._v("EXTCODESIZE")]),t._v(" 的行為不適用於正在建立中的 EOF 合約目標，即這些會像沒有程式碼的帳戶一樣回報。")]),t._v(" "),v("h2",{attrs:{id:"原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),v("p",[t._v("EVM 和/或帳戶版本控制在過去幾年中被多次討論。本提案旨在從這些討論中學習。\n有關良好的起點，請參閱以太坊魔法師協會論壇上的「以太坊帳戶版本控制」。")]),t._v(" "),v("h3",{attrs:{id:"執行時與建立時的驗證"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#執行時與建立時的驗證"}},[t._v("#")]),t._v(" 執行時與建立時的驗證")]),t._v(" "),v("p",[t._v("本規範引入了建立時驗證，這意味著：")]),t._v(" "),v("ul",[v("li",[t._v("所有具有 "),v("em",[t._v("EOFn")]),t._v(" 前綴的已建立合約都必須符合版本 "),v("em",[t._v("n")]),t._v(" 的規則。這是一個非常強大且實用的特性。客戶端可以信任已部署的程式碼是格式正確的。")]),t._v(" "),v("li",[t._v("未來，這允許在 EOF 容器中序列化 "),v("code",[t._v("JUMPDEST")]),t._v(" 映射表，並消除執行前隱含的 "),v("code",[t._v("JUMPDEST")]),t._v(" 分析需求。")]),t._v(" "),v("li",[t._v("或者完全移除對 "),v("code",[t._v("JUMPDEST")]),t._v(" 指令的需求。")]),t._v(" "),v("li",[t._v("這有助於淘汰 EVM 指令和/或功能。")]),t._v(" "),v("li",[t._v("最大的缺點是 EOF 程式碼的部署時驗證必須在兩個硬分岔中啟用。但第一步("),v("RouterLink",{attrs:{to:"/head-first-eof/eip-3541.html"}},[t._v("EIP-3541")]),t._v(")已經在倫敦分岔中部署。")],1)]),t._v(" "),v("p",[t._v("替代方案是為 EOF 進行執行時驗證。這會在每次執行合約時執行，但客戶端可能能夠快取驗證結果。這種"),v("em",[t._v("替代")]),t._v("方法具有以下特性：")]),t._v(" "),v("ul",[v("li",[t._v("因為驗證是共識層面的執行步驟，這意味著執行總是需要完整的程式碼。這使得"),v("em",[t._v("程式碼默克爾化變得不切實際")]),t._v("。")]),t._v(" "),v("li",[t._v("可以通過單一硬分岔啟用。")]),t._v(" "),v("li",[t._v("更好的向下相容性：以 "),v("code",[t._v("0xEF")]),t._v(" 位元組或 "),v("em",[t._v("EOF 前綴")]),t._v("開頭的資料合約可以被部署。然而，這是一個具有爭議的好處。")])]),t._v(" "),v("h3",{attrs:{id:"the-magic"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#the-magic"}},[t._v("#")]),t._v(" The MAGIC")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("The first byte "),v("code",[t._v("0xEF")]),t._v(" was chosen because it is reserved for this purpose by "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-3541.html"}},[t._v("EIP-3541")]),t._v(".")],1)]),t._v(" "),v("li",[v("p",[t._v("The second byte "),v("code",[t._v("0x00")]),t._v(" was chosen to avoid clashes with three contracts which were deployed on "),v("strong",[t._v("Mainnet")]),t._v(":")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("0xca7bf67ab492b49806e24b6e2e4ec105183caa01")]),t._v(": "),v("code",[t._v("EFF09f918bf09f9fa9")])]),t._v(" "),v("li",[v("code",[t._v("0x897da0f23ccc5e939ec7a53032c5e80fd1a947ec")]),t._v(": "),v("code",[t._v("EF")])]),t._v(" "),v("li",[v("code",[t._v("0x6e51d4d9be52b623a3d3a2fa8d3c5e3e01175cd0")]),t._v(": "),v("code",[t._v("EF")])])])]),t._v(" "),v("li",[v("p",[t._v("No contracts starting with "),v("code",[t._v("0xEF")]),t._v(" bytes exist on public testnets: Goerli, Ropsten, Rinkeby, Kovan and Sepolia at their London fork block.")])])]),t._v(" "),v("p",[v("strong",[t._v("NOTE")]),t._v(": This EIP MUST NOT be enabled on chains which contain bytecodes starting with "),v("code",[t._v("MAGIC")]),t._v(" and not being valid EOF.")]),t._v(" "),v("h3",{attrs:{id:"eof-version-range-start-with-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eof-version-range-start-with-1"}},[t._v("#")]),t._v(" EOF version range start with 1")]),t._v(" "),v("p",[t._v("The version number 0 will never be used in EOF, so we can call legacy code "),v("em",[t._v("EOF0")]),t._v(".\nAlso, implementations may use APIs where 0 version number denotes legacy code.")]),t._v(" "),v("h3",{attrs:{id:"section-structure"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#section-structure"}},[t._v("#")]),t._v(" Section structure")]),t._v(" "),v("p",[t._v("We have considered different questions for the sections:")]),t._v(" "),v("ul",[v("li",[t._v("Streaming headers (i.e. "),v("code",[t._v("section_header, section_data, section_header, section_data, ...")]),t._v(') are used in some other formats (such as WebAssembly). They are handy for formats which are subject to editing (adding/removing sections). That is not a useful feature for EVM. One minor benefit applicable to our case is that they do not require a specific "header terminator". On the other hand they seem to play worse with code chunking / merkleization, as it is better to have all section headers in a single chunk.')]),t._v(" "),v("li",[t._v("Whether to have a header terminator or to encode "),v("code",[t._v("number_of_sections")]),t._v(" or "),v("code",[t._v("total_size_of_headers")]),t._v(". Both raise the question of how large of a value these fields should be able to hold. A terminator byte seems to avoid the problem of choosing a size which is too small without any perceptible downside, so it is the path taken.")]),t._v(" "),v("li",[t._v("(EOF1) Whether to encode section sizes as fixed 16-bit values or some kind of variable length field (e.g. LEB128). We have opted for fixed size, because it simplifies client implementations, and 16-bit seems enough, because of the currently exposed code size limit of 24576 bytes (see "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-170.html"}},[t._v("EIP-170")]),t._v(" and "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-3860.html"}},[t._v("EIP-3860")]),t._v("). Should this be limiting in the future, a new EOF version could change the format. Besides simplifying client implementations, not using LEB128 also greatly simplifies on-chain parsing.")],1),t._v(" "),v("li",[t._v("Whether or not to have more structure to the container header for all EOF versions to follow. In order to allow future formats optimized for chunking and merkleization (verkleization) it was decided to keep it generic and specify the structure only for a specific EOF version.")])]),t._v(" "),v("h3",{attrs:{id:"data-only-contracts"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#data-only-contracts"}},[t._v("#")]),t._v(" Data-only contracts")]),t._v(" "),v("p",[t._v("See section "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-7480.html#lack-of-extdatacopy"}},[t._v("Lack of "),v("code",[t._v("EXTDATACOPY")]),t._v(" in EIP-7480")]),t._v(".")],1),t._v(" "),v("h3",{attrs:{id:"eof1-contracts-can-only-delegatecall-eof1-contracts"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eof1-contracts-can-only-delegatecall-eof1-contracts"}},[t._v("#")]),t._v(" EOF1 contracts can only "),v("code",[t._v("DELEGATECALL")]),t._v(" EOF1 contracts")]),t._v(" "),v("p",[t._v("Currently contracts can selfdestruct in three different ways (directly through "),v("code",[t._v("SELFDESTRUCT")]),t._v(", indirectly through "),v("code",[t._v("CALLCODE")]),t._v(" and indirectly through "),v("code",[t._v("DELEGATECALL")]),t._v("). "),v("RouterLink",{attrs:{to:"/head-first-eof/eip-3670.html"}},[t._v("EIP-3670")]),t._v(" disables the first two possibilities, however the third possibility remains. Allowing EOF1 contracts to only "),v("code",[t._v("DELEGATECALL")]),t._v(" other EOF1 contracts allows the following strong statement: EOF1 contract can never be destructed. Attacks based on "),v("code",[t._v("SELFDESTRUCT")]),t._v(" completely disappear for EOF1 contracts. These include destructed library contracts (e.g. Parity Multisig).")],1),t._v(" "),v("h3",{attrs:{id:"eof1-containers-have-a-size-limit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eof1-containers-have-a-size-limit"}},[t._v("#")]),t._v(" EOF1 containers have a size limit")]),t._v(" "),v("p",[t._v("Imposing an EOF-validation time limit for the size of EOF containers provides a reference limit of how large the containers should EVM implementations be able to handle when validating and processing containers. "),v("code",[t._v("MAX_INITCODE_SIZE")]),t._v(" was chosen for EOF1, as it is what contract creation currently allows for.")]),t._v(" "),v("p",[t._v("Given one of the main reasons for the limit is to avoid attack vectors on "),v("code",[t._v("JUMPDEST")]),t._v("-analysis, and EOF removes the need for "),v("code",[t._v("JUMPDEST")]),t._v("-analysis and introduces a cost structure for deploy-time analysis, in the future this limit could be increased or even lifted for EOF.")]),t._v(" "),v("h2",{attrs:{id:"向下相容性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向下相容性"}},[t._v("#")]),t._v(" 向下相容性")]),t._v(" "),v("p",[t._v("這是一個破壞性變更，因為在此之前，任何以 "),v("code",[t._v("0xEF")]),t._v(" 開頭的程式碼都無法部署（且在執行時會導致異常中止），但現在這類程式碼的某些子集可以成功部署和執行。")]),t._v(" "),v("p",[t._v("選擇這個 "),v("code",[t._v("MAGIC")]),t._v(" 數值可以確保鏈上現有的合約不會受到新規則的影響。")]),t._v(" "),v("h2",{attrs:{id:"security-considerations"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[t._v("#")]),t._v(" Security Considerations")]),t._v(" "),v("p",[t._v("With the anticipated EOF extensions, the validation is expected to have linear computational and space complexity.\nWe think that the validation cost is sufficiently covered by:")]),t._v(" "),v("ul",[v("li",[v("RouterLink",{attrs:{to:"/head-first-eof/eip-3860.html"}},[t._v("EIP-3860")]),t._v(" for "),v("em",[t._v("initcode")]),t._v(",")],1),t._v(" "),v("li",[t._v("high per-byte cost of deploying "),v("em",[t._v("code")]),t._v(".")])])])}),[],!1,null,null,null);v.default=a.exports}}]);