(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{376:function(a,t,r){"use strict";r.r(t);var e=r(17),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"什麼是以太坊虛擬機-ethereum-virtual-machine-evm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什麼是以太坊虛擬機-ethereum-virtual-machine-evm"}},[a._v("#")]),a._v(" 什麼是以太坊虛擬機 (Ethereum Virtual Machine, EVM)")]),a._v(" "),t("h2",{attrs:{id:"簡介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#簡介"}},[a._v("#")]),a._v(" 簡介")]),a._v(" "),t("p",[a._v("以太坊的最大特色在於提供一個執行程式引擎，讓所有使用者都能在完全相同的沙盒環境裡重現出一樣的行為，包含但不限於：轉帳、發行代幣、投票、DeFi 應用程式、NFT、與區塊鏈上的遊戲等等。\n而這一切的基礎是以太坊提供一個世界狀態(Global State) 用來儲存所有在區塊鏈上的資料，而實際對這個世界狀態進行修改的工具，便是以太坊虛擬機 (Ethereum Virtual Machine)的職責所在。")]),a._v(" "),t("h2",{attrs:{id:"evm-的基本特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evm-的基本特性"}},[a._v("#")]),a._v(" EVM 的基本特性")]),a._v(" "),t("ol",[t("li",[a._v("通用的世界電腦\n在設計之初，EVM 便具備圖靈完備性(我們在此不展開此名詞的解說，有興趣的朋友請參考維基百科以獲得更多資訊)，可以想像成他就是一台個人電腦，跟你的筆記型電腦或桌上型電腦一樣，開發者撰寫了程式（以太坊的世界裡，我們稱之為智慧合約），使用者則是透過這些程式所提供的介面與之互動。")]),a._v(" "),t("li",[a._v("無隨機性的執行結果\n為了確保每一個人在執行相同的城市與相同的輸入時，都能得到相同的結果，EVM 不允許任何隨機性行為。比如說在普通的電腦裡有個機制是能讓你取得一個隨機數字，但我們並不能在 EVM 中提供這類的功能，因為這個隨機的發生將導致不同人在執行時，結果相異，進而破壞「共識」導致整個區塊鏈驗證的崩潰。")]),a._v(" "),t("li",[a._v("沙盒環境\n我們日常所使用的電腦，有許多種不同的硬體來執行運算，比如 Intel/AMD 的 x64 架構，比如 Apple Silicon / Qualcomm 的 ARM 架構，這些不同的硬體架構在執行的時候，相同的指令所需的時間可能不一致，且規格十分多元，這將導致在不同的硬體上，執行相同的程式所需的時間不同，且最後的結果也可能不同（比如涉及浮點數相關實作的部分）。為了避免這類的情況發生，EVM 提供了一個虛擬的硬體環境，讓所有人都能在相同的環境下執行程式，這樣就能確保每一個人在執行相同的程式時，所需的指令與執行的花費都能有完全相同的保證，且最終得到完全相同的結果。")])]),a._v(" "),t("h2",{attrs:{id:"evm-架構"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evm-架構"}},[a._v("#")]),a._v(" EVM 架構")]),a._v(" "),t("p",[a._v("在探討 EVM 的架構前，我們先來看看他的執行流程，以了解裡面有哪些元件會參與整個運作。")]),a._v(" "),t("h3",{attrs:{id:"evm-的執行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evm-的執行流程"}},[a._v("#")]),a._v(" EVM 的執行流程")]),a._v(" "),t("p",[a._v("當一筆合約互動的交易被傳遞給 EVM 時，EVM 將根據交易的型態決定要啟動哪一種方式來執行這筆交易，這裡有兩種方式：")]),a._v(" "),t("ol",[t("li",[a._v("建立新的合約\n當發現使用者的意圖是要建立一個新的合約時，EVM 便會從該交易中取得合約的位元組碼，並將其載入到 EVM 的指令區中，接著開始執行部署合約的進入點，要注意的是這個「部署」執行後的結果就是將「最終要被互動的合約的位元組碼」寫入世界狀態中。")]),a._v(" "),t("li",[a._v("執行現有的合約\n若使用者的意圖是要與已經存在的合約進行互動，EVM 則從交易欲圖互動的位址中取得合約的位元組碼，並將其載入到 EVM 的指令區中，接著開始執行合約的進入點。")])]),a._v(" "),t("h3",{attrs:{id:"位元組碼"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#位元組碼"}},[a._v("#")]),a._v(" 位元組碼")]),a._v(" "),t("p",[a._v("EVM 定義了一套指令集，我們稱為 EVM Assembly Language 或者稱 Opcodes，這套指令集是以位元組碼的方式來表示，這些指令將會被 EVM 逐一執行，並根據指令的不同來改變 EVM 的狀態。")]),a._v(" "),t("h3",{attrs:{id:"程式計數器-program-counter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程式計數器-program-counter"}},[a._v("#")]),a._v(" 程式計數器 (Program Counter)")]),a._v(" "),t("p",[a._v("為了能清楚地知道目前 EVM 正在執行的指令是哪一條，因此程式計數器的角色便是紀錄目前正在執行的指令位置，若沒有透過特殊指令使其跳到特定位置，則預設會自動往下一條指令跳動。")]),a._v(" "),t("h3",{attrs:{id:"gas-計數器-gas-counter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gas-計數器-gas-counter"}},[a._v("#")]),a._v(" Gas 計數器 (Gas Counter)")]),a._v(" "),t("p",[a._v("人都會犯錯，有時候程式就是會寫成我們不願看到的樣子，但這就是現實。為了避免惡意程式或者是錯誤程式導致 EVM 陷入無窮迴圈，進而癱瘓 EVM 的執行並使得整個區塊鏈停擺，在此引入了 Gas 機制，每一條指令都會消耗特定的 Gas，當 Gas 用盡時，EVM 便會強制停止執行，並將世界狀態回滾到執行前的模樣。")]),a._v(" "),t("h3",{attrs:{id:"記憶體模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#記憶體模型"}},[a._v("#")]),a._v(" 記憶體模型")]),a._v(" "),t("ul",[t("li",[a._v("Stack (堆疊)")]),a._v(" "),t("li",[a._v("Memory (記憶體)")]),a._v(" "),t("li",[a._v("Storage (儲存空間)")])])])}),[],!1,null,null,null);t.default=s.exports}}]);